<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Convite ‚Äì Mostra Cultural</title>
<style>
:root{
  /* Ajuste esta vari√°vel para mudar o tamanho do cubo/cards */
  --cube-size: 300px; /* ex: 250px, 300px, 350px */
  --cube-half: calc(var(--cube-size) / 2);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  background-color: rgb(15,15,15);
  overflow: auto; /* permite rolar a p√°gina para ver a imagem longa */
  font-family: Arial, sans-serif;
  color: white;
  padding: 24px 12px; /* espa√ßamento superior para ficar bonito */
}

/* Wrapper para centralizar e controlar espa√ßamento */
.container {
  width: 100%;
  max-width: 1100px;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 85px; /* üîπ controla a dist√¢ncia do cubo do topo */
}

/* === Cubo === */
.cube {
  position: relative;
  width: var(--cube-size);
  height: var(--cube-size);
  transform-style: preserve-3d;
  animation: rotate-cube 10s linear infinite;
  cursor: pointer;
  transition: transform 1.5s ease-in-out, scale 1s ease-in-out;
  margin: 10px 0;
}

@keyframes rotate-cube {
  0% { transform: rotateX(-30deg) rotateY(0deg); }
  100% { transform: rotateX(-30deg) rotateY(360deg); }
}

.cube div {
  position: absolute;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
}

/* Faces do cubo: os elementos pai (span) */
.cube div span {
  position: absolute;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transform: rotateY(calc(90deg * var(--i))) translateZ(var(--cube-half));
}

.top {
  position: absolute;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transform: rotateX(90deg) translateZ(var(--cube-half));
}

.bottom {
  position: absolute;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transform: rotateX(90deg) translateZ(calc(-1 * var(--cube-half)));
}

/* Conte√∫do vis√≠vel da face (imagem) */
.face-content {
  position: absolute;
  inset: 0;
  background-size: cover;
  background-position: center;
  display: flex;
  align-items: center;
  justify-content: center;
  backface-visibility: hidden;
  border: 1px solid rgba(255,255,255,0.15);
  transition: transform 0.45s ease, opacity 0.45s ease, background-image 0.8s ease;
  transform-origin: center;
  --img-rot: 0deg;
  transform: rotate(var(--img-rot));
  pointer-events: none;
}

.cube.rotate .face-content,
.cube.rotate .top .face-content,
.cube.rotate .bottom .face-content {
  opacity: 0.8;
}

/* Modo cartas (pausa rota√ß√£o do cubo) */
.cube.card-mode {
  animation: none;
  transform: rotateX(0deg) rotateY(0deg) scale(1.12);
}

.cube.card-mode span,
.cube.card-mode .top {
  transform: translateZ(0) rotateY(0) rotateX(0);
  pointer-events: none;
}

.cube.card-mode .bottom {
  transform: rotateX(90deg) translateZ(calc(-1 * var(--cube-half)));
}

/* Carta vis√≠vel: quanto "sai" para frente */
.card-visible {
  opacity: 1 !important;
  transform: translateZ(calc(var(--cube-size))) scale(1.05) !important;
  pointer-events: auto !important;
}

/* Texto e informa√ß√µes */
.info {
  margin-top: 14px;
  font-size: 18px;
  opacity: 0.95;
  text-align: center;
  opacity: 0.55;
}

/* Controles de rota√ß√£o (APENAS UM BOT√ÉO) - aparece s√≥ no modo carta */
.controls {
  position: relative;
  margin-top: 12px;
  display: none;
  gap: 8px;
  z-index: 50;
}

.cube.card-mode + .controls,
.controls[aria-hidden="false"] {
  display: flex;
}

/* Bot√£o √∫nico */
.controls button {
  background: rgba(255,255,255,0.06);
  color: white;
  border: 1px solid rgba(255,255,255,0.12);
  padding: 10px 16px;
  font-size: 16px;
  border-radius: 10px;
  cursor: pointer;
  backdrop-filter: blur(4px);
  transition: transform 0.12s ease, background 0.12s ease;
}

.controls button:active { transform: scale(0.98); }
.controls button:hover { background: rgba(255,255,255,0.09); }

/* Se√ß√£o da imagem longa (detalhes/info) */
.details {
  width: 100%;
  display: flex;
  justify-content: center;
  margin-top: 28px;
  padding-bottom: 80px; /* espa√ßo para scroll final */
}

.details img {
  width: 100%;
  max-width: 820px; /* limite de largura para telas grandes */
  height: auto;
  display: block;
  border-radius: 6px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

/* Responsivo */
@media (max-width: 600px) {
  :root { --cube-size: 260px; --cube-half: calc(var(--cube-size) / 2); }
  .info { font-size: 15px; }
  .controls button { padding: 9px 12px; font-size: 15px; }
  .details img { max-width: 94%; }
}
</style>
</head>
<body>
  <div class="container">
    <div class="cube rotate" id="cube" aria-label="Cubo do convite">
      <div>
        <span style="--i:0;"><div class="face-content" style="background-image: url('img/meio.jpg');"></div></span>
        <span style="--i:1;"><div class="face-content" style="background-image: url('img/meio.jpg');"></div></span>
        <span style="--i:2;"><div class="face-content" style="background-image: url('img/meio.jpg');"></div></span>
        <span style="--i:3;"><div class="face-content" style="background-image: url('img/meio.jpg');"></div></span>
      </div>

      <div class="top"><div class="face-content" style="background-image: url('img/meio.jpg');"></div></div>
      <div class="bottom"><div class="face-content" style="background-image: url('img/meio.jpg');"></div></div>
    </div>

    <!-- Controles (bot√£o √∫nico) -->
    <div class="controls" id="controls" aria-hidden="true">
      <button id="rotateBtn" title="Girar 90¬∞">‚ü≥</button>
    </div>


    <!-- AQUI: imagem longa de informa√ß√µes -->
    <div class="details">
      <!-- Substitua o src abaixo pelo caminho real do seu arquivo grande.
           Ex.: 'img/Dentro do Lado de Fora_page-0001.jpg' ou 'img/info.jpg' -->
      <img src="img/info.jpg" alt="Informa√ß√µes do convite (detalhes)">
    </div>
  </div>

<script>
const cube = document.getElementById("cube");
const faces = cube.querySelectorAll("span, .top, .bottom");
const info = document.getElementById("info");
const controls = document.getElementById("controls");
const rotateBtn = document.getElementById("rotateBtn");

let step = 0;
let inCardMode = false;

/* Imagens do convite (substitua pelos seus caminhos reais) */
const conviteImgs = [
  'img/info2.jpg',
  'img/face1.jpg',
  'img/face2.jpg',
  'img/face3.jpg',
  'img/face4.jpg'
];

const padraoImg = 'img/meio.jpg';

function contentOf(faceEl) { return faceEl.querySelector('.face-content'); }
function resetRotation(faceEl) { const c = contentOf(faceEl); if (c) c.style.setProperty('--img-rot','0deg'); }

function mostrarConvite(index) {
  faces.forEach(face => {
    const c = contentOf(face);
    if (c) { c.style.backgroundImage = `url('${padraoImg}')`; c.style.setProperty('--img-rot','0deg'); }
    face.classList.remove('card-visible');
  });

  const face = faces[index];
  const content = contentOf(face);
  if (!face || !content) return;
  content.style.backgroundImage = `url('${conviteImgs[index]}')`;
  face.classList.add('card-visible');
  info.textContent = "Clique na √°rea do cubo para avan√ßar. Use o bot√£o para girar a imagem.";
}

/* Oculta a carta atual e reseta rota√ß√£o */
function ocultarConvite(index) {
  const face = faces[index];
  if (!face) return;
  face.classList.remove('card-visible');
  const content = contentOf(face);
  if (content) content.style.setProperty('--img-rot','0deg');
}

function voltarCubo() {
  info.textContent = "Voltando ao cubo...";
  controls.setAttribute('aria-hidden','true');
  setTimeout(() => {
    faces.forEach(face => {
      const c = contentOf(face);
      if (c) c.style.backgroundImage = `url('${padraoImg}')`;
      resetRotation(face);
    });
    cube.classList.remove("card-mode");
    cube.classList.add("rotate");
    step = 0;
    inCardMode = false;
    info.textContent = "Clique no cubo";
    // rolar para o topo do cubo para feedback visual
    window.scrollTo({ top: document.querySelector('.container').offsetTop, behavior: 'smooth' });
  }, 1200);
}

/* Clique no cubo: entra/sai do modo carta ou avan√ßa cartas */
cube.addEventListener("click", () => {
  if (!inCardMode) {
    cube.classList.remove("rotate");
    cube.classList.add("card-mode");
    info.textContent = "Clique para ver a pr√≥xima parte do convite...";
    inCardMode = true;
    step = 0;
    mostrarConvite(step);
    controls.setAttribute('aria-hidden','false');
    // garante que o cubo esteja vis√≠vel no topo da viewport
    cube.scrollIntoView({ behavior: 'smooth', block: 'center' });
  } else {
    ocultarConvite(step);
    step++;
    if (step < conviteImgs.length) {
      setTimeout(() => mostrarConvite(step), 350);
    } else {
      voltarCubo();
    }
  }
});

/* Fun√ß√µes de rota√ß√£o (aplicadas s√≥ √† imagem da face atual) */
function currentFace() { if (!inCardMode) return undefined; return faces[step]; }
function getCurrentRotation(contentEl) {
  const val = getComputedStyle(contentEl).getPropertyValue('--img-rot') || '0deg';
  return parseInt(val.replace('deg','')) || 0;
}
function setRotation(contentEl, degrees) { contentEl.style.setProperty('--img-rot', `${degrees}deg`); }
function rotateCurrentBy(delta) {
  const face = currentFace();
  if (!face) return;
  const content = contentOf(face);
  if (!content) return;
  let now = getCurrentRotation(content);
  now = now + delta;
  now = ((now % 360) + 360) % 360;
  setRotation(content, now);
}

/* Bot√£o √∫nico: gira 90¬∞ hor√°rio a cada clique */
rotateBtn.addEventListener('click', (e) => {
  e.stopPropagation(); // impede que o clique avance a carta
  rotateCurrentBy(90);
});

/* Suporte a touch (mobile) para bot√£o: toque normal j√° funciona; tamb√©m permitir swipe para girar imagem */
let touchStartX = null;
let touchStartY = null;
const sensitivity = 20;

cube.addEventListener('touchstart', (e) => {
  if (!inCardMode) return;
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
}, { passive: true });

cube.addEventListener('touchend', (e) => {
  if (!inCardMode || touchStartX === null) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  // se swipe horizontal curto: gira a imagem
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > sensitivity) {
    if (dx > 0) rotateCurrentBy(-90); else rotateCurrentBy(90);
  }
  touchStartX = null;
  touchStartY = null;
}, { passive: true });

</script>

</body>
</html>
